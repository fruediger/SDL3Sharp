using Sdl3Sharp.Events;
using Sdl3Sharp.Internal.Interop;
using Sdl3Sharp.SourceGeneration;
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using unsafe SDL_EventFilter = delegate* unmanaged[Cdecl]<void*, Sdl3Sharp.Events.Event*, Sdl3Sharp.Internal.Interop.CBool>;

namespace Sdl3Sharp;

partial class Sdl
{
    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    private unsafe static CBool EventFilterImpl(void* userdata, Event* @event)
    {
        if (userdata is not null && GCHandle.FromIntPtr(unchecked((IntPtr)userdata)) is { IsAllocated: true, Target: EventFilter filter })
        {
            return filter(new(ref Unsafe.AsRef<Event>(@event)));
        }

        return true; // default to true (a.k.a. keep the event)
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    private unsafe static CBool EventWatchImpl(void* userdata, Event* @event)
    {
        if (userdata is not null && GCHandle.FromIntPtr(unchecked((IntPtr)userdata)) is { IsAllocated: true, Target: EventWatch watch })
        {
            watch(new(ref Unsafe.AsRef<Event>(@event)));
        }

        return true; // always return true, since the return doesn't matter anyways
    }

    /// <summary>
    /// Add a callback to be triggered when an event is added to the event queue
    /// </summary>
    /// <param name="filter">An SDL_EventFilter function to call when an event happens</param>
    /// <param name="userdata">A pointer that is passed to <c><paramref name="filter"/></c></param>
    /// <returns>Returns true on success or false on failure; call <see href="https://wiki.libsdl.org/SDL3/SDL_GetError">SDL_GetError</see>() for more information</returns>
    /// <remarks>
    /// <para>
    /// <c><paramref name="filter"/></c> will be called when an event happens, and its return value is ignored.
    /// </para>
    /// <para>
    /// <em>WARNING</em>: Be very careful of what you do in the event filter function, as it may run in a different thread!
    /// </para>
    /// <para>
    /// If the quit event is generated by a signal (e.g. SIGINT), it will bypass the internal queue and be delivered to the watch callback immediately, and arrive at the next event poll.
    /// </para>
    /// <para>
    /// Note: the callback is called for events posted by the user through <see href="https://wiki.libsdl.org/SDL3/SDL_PushEvent">SDL_PushEvent</see>(), but not for disabled events,
    /// nor for events by a filter callback set with <see href="https://wiki.libsdl.org/SDL3/SDL_SetEventFilter">SDL_SetEventFilter</see>(),
    /// nor for events posted by the user through <see href="https://wiki.libsdl.org/SDL3/SDL_PeepEvents">SDL_PeepEvents</see>().
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_AddEventWatch">SDL_AddEventWatch</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial CBool SDL_AddEventWatch(SDL_EventFilter filter, void* userdata);

    /// <summary>
    /// Run a specific filter function on the current event queue, removing any events for which the filter returns false
    /// </summary>
    /// <param name="filter">The <see href="">SDL_EventFilter</see> function to call when an event happens</param>
    /// <param name="userdata">A pointer that is passed to <c><paramref name="filter"/></c></param>
    /// <remarks>
    /// <para>
    /// See <see href="https://wiki.libsdl.org/SDL3/SDL_SetEventFilter">SDL_SetEventFilter</see>() for more information.
    /// Unlike <see href="https://wiki.libsdl.org/SDL3/SDL_SetEventFilter">SDL_SetEventFilter</see>(), this function does not change the filter permanently, it only uses the supplied filter until this function returns.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_FilterEvents">SDL_FilterEvents</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial void SDL_FilterEvents(SDL_EventFilter filter, void* userdata);

    /// <summary>
    /// Clear events of a specific type from the event queue
    /// </summary>
    /// <param name="type">The type of event to be cleared; see <see href="https://wiki.libsdl.org/SDL3/SDL_EventType">SDL_EventType</see> for details</param>
    /// <remarks>
    /// <para>
    /// This will unconditionally remove any events from the queue that match type.
    /// If you need to remove a range of event types, use <see href="https://wiki.libsdl.org/SDL3/SDL_FlushEvents">SDL_FlushEvents</see>() instead.
    /// </para>
    /// <para>
    /// It's also normal to just ignore events you don't care about in your event loop without calling this function.
    /// </para>
    /// <para>
    /// This function only affects currently queued events.
    /// If you want to make sure that all pending OS events are flushed, you can call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>() on the main thread immediately before the flush call.
    /// </para>
    /// <para>
    /// If you have user events with custom data that needs to be freed, you should use <see href="https://wiki.libsdl.org/SDL3/SDL_PeepEvents">SDL_PeepEvents</see>() to remove and clean up those events before calling this function.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_FlushEvent">SDL_FlushEvent</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal static partial void SDL_FlushEvent(EventType type);

    /// <summary>
    /// Clear events of a range of types from the event queue
    /// </summary>
    /// <param name="minType">The low end of event type to be cleared, inclusive; see <see href="">SDL_EventType</see> for details</param>
    /// <param name="maxType">The high end of event type to be cleared, inclusive; see <see href="">SDL_EventType</see> for details</param>
    /// <remarks>
    /// <para>
    /// This will unconditionally remove any events from the queue that are in the range of <c><paramref name="minType"/></c> to <c><paramref name="maxType"/></c>, inclusive.
    /// If you need to remove a single event type, use <see href="https://wiki.libsdl.org/SDL3/SDL_FlushEvent">SDL_FlushEvent</see>() instead.
    /// </para>
    /// <para>
    /// It's also normal to just ignore events you don't care about in your event loop without calling this function.
    /// </para>
    /// <para>
    /// This function only affects currently queued events.
    /// If you want to make sure that all pending OS events are flushed, you can call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>() on the main thread immediately before the flush call.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_FlushEvents">SDL_FlushEvents</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal static partial void SDL_FlushEvents(EventType minType, EventType maxType);

    /// <summary>
    /// Query the current event filter
    /// </summary>
    /// <param name="filter">The current callback function will be stored here</param>
    /// <param name="userdata">The pointer that is passed to the current event filter will be stored here</param>
    /// <returns>Returns true on success or false if there is no event filter set</returns>
    /// <remarks>
    /// <para>
    /// This function can be used to "chain" filters, by saving the existing filter before replacing it with a function that will call that saved filter.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_GetWindowFromEvent">SDL_GetWindowFromEvent</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial CBool SDL_GetEventFilter(SDL_EventFilter* filter, void** userdata);

    /// <summary>
    /// Check for the existence of a certain event type in the event queue
    /// </summary>
    /// <param name="type">The type of event to be queried; see <see href="https://wiki.libsdl.org/SDL3/SDL_EventType">SDL_EventType</see> for details</param>
    /// <returns>Returns true if events matching <c><paramref name="type"/></c> are present, or false if events matching <c><paramref name="type"/></c> are not present</returns>
    /// <remarks>
    /// <para>
    /// If you need to check for a range of event types, use <see href="https://wiki.libsdl.org/SDL3/SDL_HasEvents">SDL_HasEvents</see>() instead.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_HasEvent">SDL_HasEvent</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal static partial CBool SDL_HasEvent(EventType type);

    /// <summary>
    /// Check for the existence of certain event types in the event queue
    /// </summary>
    /// <param name="minType">The low end of event type to be queried, inclusive; see <see href="https://wiki.libsdl.org/SDL3/SDL_EventType">SDL_EventType</see> for details</param>
    /// <param name="maxType">The high end of event type to be queried, inclusive; see <see href="https://wiki.libsdl.org/SDL3/SDL_EventType">SDL_EventType</see> for details</param>
    /// <returns>Returns true if events with type &gt;= <c><paramref name="minType"/></c> and &lt;= <c><paramref name="maxType"/></c> are present, or false if not</returns>
    /// <remarks>
    /// <para>
    /// If you need to check for a single event type, use <see href="https://wiki.libsdl.org/SDL3/SDL_HasEvent">SDL_HasEvent</see>() instead.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_HasEvents">SDL_HasEvents</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal static partial CBool SDL_HasEvents(EventType minType, EventType maxType);

    /// <summary>
    /// Check the event queue for messages and optionally return them
    /// </summary>
    /// <param name="events">Destination buffer for the retrieved events, may be NULL to leave the events in the queue and return the number of events that would have been stored</param>
    /// <param name="numevents">If <paramref name="action"/> is <see href="https://wiki.libsdl.org/SDL3/SDL_ADDEVENT">SDL_ADDEVENT</see>, the number of events to add back to the event queue; if <paramref name="action"/> is <see href="https://wiki.libsdl.org/SDL3/SDL_PEEKEVENT">SDL_PEEKEVENT</see> or <see href="https://wiki.libsdl.org/SDL3/SDL_GETEVENT">SDL_GETEVENT</see>, the maximum number of events to retrieve</param>
    /// <param name="action">Action to take; see <see href="https://wiki.libsdl.org/SDL3/SDL_PeepEvents#remarks">Remarks</see> for details</param>
    /// <param name="minType">Minimum value of the event type to be considered; <see href="https://wiki.libsdl.org/SDL3/SDL_EVENT_FIRST">SDL_EVENT_FIRST</see> is a safe choice</param>
    /// <param name="maxType">Maximum value of the event type to be considered; <see href="https://wiki.libsdl.org/SDL3/SDL_EVENT_LAST">SDL_EVENT_LAST</see> is a safe choice</param>
    /// <returns>Returns the number of events actually stored or -1 on failure; call <see href="https://wiki.libsdl.org/SDL3/SDL_GetError">SDL_GetError</see>() for more information</returns>
    /// <remarks>
    /// <para>
    /// <c><paramref name="action"/></c> may be any of the following:
    /// <list type="bullet">
    ///		<item>
    ///			<term><see href="https://wiki.libsdl.org/SDL3/SDL_ADDEVENT"><c>SDL_ADDEVENT</c></see></term>
    ///			<description>Up to <c><paramref name="numevents"/></c> events will be added to the back of the event queue</description>
    ///		</item>
    ///		<item>
    ///			<term><see href="https://wiki.libsdl.org/SDL3/SDL_PEEKEVENT"><c>SDL_PEEKEVENT</c></see></term>
    ///			<description>
    ///				<c><paramref name="numevents"/></c> events at the front of the event queue, within the specified minimum and maximum type, will be returned to the caller and will <em>not</em> be removed from the queue.
    ///				If you pass NULL for <c><paramref name="events"/></c>, then <c><paramref name="numevents"/></c> is ignored and the total number of matching events will be returned.
    ///			</description>
    ///		</item>
    ///		<item>
    ///			<term><see href="https://wiki.libsdl.org/SDL3/SDL_GETEVENT"><c>SDL_GETEVENT</c></see></term>
    ///			<description>Up to <c><paramref name="numevents"/></c> events at the front of the event queue, within the specified minimum and maximum type, will be returned to the caller and will be removed from the queue</description>
    ///		</item>
    /// </list>
    /// </para>
    /// <para>
    /// You may have to call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>() before calling this function.
    /// Otherwise, the events may not be ready to be filtered when you call <see href="https://wiki.libsdl.org/SDL3/SDL_PeepEvents">SDL_PeepEvents</see>().
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_PeepEvents">SDL_PeepEvents</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial int SDL_PeepEvents(Event* events, int numevents, EventAction action, EventType minType, EventType maxType);

    /// <summary>
    /// Poll for currently pending events
    /// </summary>
    /// <param name="event">The <see href="https://wiki.libsdl.org/SDL3/SDL_Event">SDL_Event</see> structure to be filled with the next event from the queue, or NULL</param>
    /// <returns>Returns true if this got an event or false if there are none available</returns>
    /// <remarks>
    /// <para>
    /// If <c><paramref name="event"/></c> is not NULL, the next event is removed from the queue and stored in the <see href="https://wiki.libsdl.org/SDL3/SDL_Event">SDL_Event</see> structure pointed to by <c><paramref name="event"/></c>.
    /// The 1 returned refers to this event, immediately stored in the SDL Event structure -- not an event to follow.
    /// </para>
    /// <para>
    /// If <c><paramref name="event"/></c> is NULL, it simply returns 1 if there is an event in the queue, but will not remove it from the queue.
    /// </para>
    /// <para>
    /// As this function may implicitly call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>(), you can only call this function in the thread that set the video mode.
    /// </para>
    /// <para>
    /// <see href="https://wiki.libsdl.org/SDL3/SDL_PollEvent">SDL_PollEvent</see>() is the favored way of receiving system events since it can be done from the main loop
    /// and does not suspend the main loop while waiting on an event to be posted.
    /// </para>
    /// <para>
    /// The common practice is to fully process the event queue once every frame, usually as a first step before updating the game's state:
    /// <code>
    /// while (game_is_still_running) {
    ///		SDL_Event event;
    ///		while (SDL_PollEvent(&amp;event)) {  // poll until all events are handled!
    ///			// decide what to do with this event.
    ///		}
    ///		
    ///		// update game state, draw the current frame
    /// }
    /// </code>
    /// </para>
    /// <para>
    /// This function should only be called on the main thread.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_PollEvent">SDL_PollEvent</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial CBool SDL_PollEvent(Event* @event);

    /// <summary>
    /// Pump the event loop, gathering events from the input devices
    /// </summary>
    /// <remarks>
    /// <para>
    /// This function updates the event queue and internal input device state.
    /// </para>
    /// <para>
    /// <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>() gathers all the pending input information from devices and places it in the event queue.
    /// Without calls to <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>() no events would ever be placed on the queue.
    /// Often the need for calls to <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>() is hidden from the user since
    /// <see href="https://wiki.libsdl.org/SDL3/SDL_PollEvent">SDL_PollEvent</see>() and <see href="https://wiki.libsdl.org/SDL3/SDL_WaitEvent">SDL_WaitEvent</see>() implicitly call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>().
    /// However, if you are not polling or waiting for events (e.g. you are filtering them), then you must call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>() to force an event queue update.
    /// </para>
    /// <para>
    /// This function should only be called on the main thread.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal static partial void SDL_PumpEvents();

    /// <summary>
    /// Add an event to the event queue
    /// </summary>
    /// <param name="event">The <see href="https://wiki.libsdl.org/SDL3/SDL_Event">SDL_Event</see> to be added to the queue</param>
    /// <returns>Returns true on success, false if the event was filtered or on failure; call <see href="https://wiki.libsdl.org/SDL3/SDL_GetError">SDL_GetError</see>() for more information. A common reason for error is the event queue being full.</returns>
    /// <remarks>
    /// <para>
    /// The event queue can actually be used as a two way communication channel. Not only can events be read from the queue, but the user can also push their own events onto it.
    /// <c><paramref name="event"/></c> is a pointer to the event structure you wish to push onto the queue.
    /// The event is copied into the queue, and the caller may dispose of the memory pointed to after <see href="https://wiki.libsdl.org/SDL3/SDL_PushEvent">SDL_PushEvent</see>() returns.
    /// </para>
    /// <para>
    /// Note: Pushing device input events onto the queue doesn't modify the state of the device within SDL.
    /// </para>
    /// <para>
    /// Note: Events pushed onto the queue with <see href="https://wiki.libsdl.org/SDL3/SDL_PushEvent">SDL_PushEvent</see>() get passed through the event filter but events added with <see href="https://wiki.libsdl.org/SDL3/SDL_PeepEvents">SDL_PeepEvents</see>() do not.
    /// </para>
    /// <para>
    /// For pushing application-specific events, please use <see href="https://wiki.libsdl.org/SDL3/SDL_RegisterEvents">SDL_RegisterEvents</see>() to get an event type that does not conflict with other code that also wants its own custom event types.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_PushEvent">SDL_PushEvent</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial CBool SDL_PushEvent(Event* @event);

    /// <summary>
    /// Remove an event watch callback added with <see href="https://wiki.libsdl.org/SDL3/SDL_AddEventWatch">SDL_AddEventWatch</see>()
    /// </summary>
    /// <param name="filter">The function originally passed to <see href="https://wiki.libsdl.org/SDL3/SDL_AddEventWatch">SDL_AddEventWatch</see>()</param>
    /// <param name="userdata">The pointer originally passed to <see href="https://wiki.libsdl.org/SDL3/SDL_AddEventWatch">SDL_AddEventWatch</see>()</param>
    /// <remarks>
    /// This function takes the same input as <see href="https://wiki.libsdl.org/SDL3/SDL_AddEventWatch">SDL_AddEventWatch</see>() to identify and delete the corresponding callback.
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_RemoveEventWatch">SDL_RemoveEventWatch</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial void SDL_RemoveEventWatch(SDL_EventFilter filter, void* userdata);

    /// <summary>
    /// Set up a filter to process all events before they are added to the internal event queue
    /// </summary>
    /// <param name="filter">An <see href="https://wiki.libsdl.org/SDL3/SDL_EventFilter">SDL_EventFilter</see> function to call when an event happens</param>
    /// <param name="userdata">A pointer that is passed to <c><paramref name="filter"/></c></param>
    /// <remarks>
    /// <para>
    /// If you just want to see events without modifying them or preventing them from being queued, you should use <see href="https://wiki.libsdl.org/SDL3/SDL_AddEventWatch">SDL_AddEventWatch</see>() instead.
    /// </para>
    /// <para>
    /// If the filter function returns true when called, then the event will be added to the internal queue.
    /// If it returns false, then the event will be dropped from the queue, but the internal state will still be updated.
    /// This allows selective filtering of dynamically arriving events.
    /// </para>
    /// <para>
    /// <em>WARNING</em>: Be very careful of what you do in the event filter function, as it may run in a different thread!
    /// </para>
    /// <para>
    /// On platforms that support it, if the quit event is generated by an interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the application at the next event poll.
    /// </para>
    /// <para>
    /// Note: Disabled events never make it to the event filter function; see <see href="https://wiki.libsdl.org/SDL3/SDL_SetEventEnabled">SDL_SetEventEnabled</see>().
    /// </para>
    /// <para>
    /// Note: Events pushed onto the queue with <see href="https://wiki.libsdl.org/SDL3/SDL_PushEvent">SDL_PushEvent</see>() get passed through the event filter,
    /// but events pushed onto the queue with <see href="https://wiki.libsdl.org/SDL3/SDL_PeepEvents">SDL_PeepEvents</see>() do not.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_SetEventFilter">SDL_SetEventFilter</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial void SDL_SetEventFilter(SDL_EventFilter filter, void* userdata);

    /// <summary>
    /// Wait indefinitely for the next available event
    /// </summary>
    /// <param name="event">The <see href="https://wiki.libsdl.org/SDL3/SDL_Event">SDL_Event</see> structure to be filled in with the next event from the queue, or NULL.</param>
    /// <returns>Returns true on success or false if there was an error while waiting for events; call <see href="https://wiki.libsdl.org/SDL3/SDL_GetError">SDL_GetError</see>() for more information.</returns>
    /// <remarks>
    /// <para>
    /// If <c><paramref name="event"/></c> is not NULL, the next event is removed from the queue and stored in the <see href="https://wiki.libsdl.org/SDL3/SDL_Event">SDL_Event</see> structure pointed to by event.
    /// </para>
    /// <para>
    /// As this function may implicitly call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>(), you can only call this function in the thread that initialized the video subsystem.
    /// </para>
    /// <para>
    /// This function should only be called on the main thread.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_WaitEvent">SDL_WaitEvent</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial CBool SDL_WaitEvent(Event* @event);

    /// <summary>
    /// Wait until the specified timeout (in milliseconds) for the next available event
    /// </summary>
    /// <param name="event">The <see href="https://wiki.libsdl.org/SDL3/SDL_Event">SDL_Event</see> structure to be filled in with the next event from the queue, or NULL</param>
    /// <param name="timeoutMS">The maximum number of milliseconds to wait for the next available event</param>
    /// <returns>Returns true if this got an event or false if the timeout elapsed without any events available</returns>
    /// <remarks>
    /// <para>
    /// If <c><paramref name="event"/></c> is not NULL, the next event is removed from the queue and stored in the <see href="https://wiki.libsdl.org/SDL3/SDL_Event">SDL_Event</see> structure pointed to by event.
    /// </para>
    /// <para>
    /// As this function may implicitly call <see href="https://wiki.libsdl.org/SDL3/SDL_PumpEvents">SDL_PumpEvents</see>(), you can only call this function in the thread that initialized the video subsystem.
    /// </para>
    /// <para>
    /// The timeout is not guaranteed, the actual wait time could be longer due to system scheduling.
    /// </para>
    /// <para>
    /// This function should only be called on the main thread.
    /// </para>
    /// </remarks>
    /// <seealso href="https://wiki.libsdl.org/SDL3/SDL_WaitEventTimeout">SDL_WaitEventTimeout</seealso>
    [NativeImportFunction<Library>(CallConvs = [typeof(CallConvCdecl)])]
    internal unsafe static partial CBool SDL_WaitEventTimeout(Event* @event, int timeoutMS);
}
